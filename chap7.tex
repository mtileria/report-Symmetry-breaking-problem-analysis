\section{Self Assessment}
\label{chap:7}


In this section, I will present a personal evaluation of this final dissertation.  The evaluation includes the progression of the project, acquired skills and a description of professional issues, in particular about correct citation and code acknowledgement. 

I started with this project at the end of May, one week after the end of the exams period. I began to read about the symmetry breaking problem in distributed computing and implemented 2 Leader Election algorithms for ring topologies, which we studied in the Advanced Distributed System course. After the first week of June, I decided to work on the Maximal Independent Set problem. After read several papers and online materials, I started implementation of the algorithm proposed in \cite{} with a global synchronization technique. By the end of June, I started with the Alpha and Beta synchronizer implementation and it was finished by the middle of July. At this point, I have one algorithm for the MIS and three synchronization techniques. After that I began to write the report and did some minors changes to the implementation.

In this project, I was able to consolidate my knowledge of distributed programming. In the course about distributed computing, I had the opportunity of implementing distributed programs and learnt the Actor model in Elixir. At the beginning it was difficult, although it was not the first time I used a functional language, it was the first time that I had to build a system with interesting features. Besides that, in the Wireless Sensor Networks course, I implemented two gossip algorithm on Arduino. These experience help me to understand the model for distributed programming and prepared the path for this dissertation. After I complete the implementation of symmetry breaking problems for this project (Leader Election and Maximal Independent Set)  and experience that I gained in the courses, I feel more confident about my ability to implement and design distributed applications.  

I also learnt how important is the proof of correctness of an algorithm. I realise this when I was testing the algorithms for a large number of processes. Sometimes, for more than 10000 processes, the algorithm fails to finish but not for smaller size. Only after analysing the correctness I could check where was the error. Trying to debug an algorithm for such a big size of network it was not suitable and the theoretical knowledge gain during the course help me to solve the problem. 


During the implementation of the simulator, I used open source code in order to generate the network topologies for the tests. First, I used the open source library (GPLv3) \textbf{algs4} written in Java, which is part of the book \textbf{Algorithms $4^th$ Edition} of Sedgewick and Wayne. This library has a section for generating random graphs which include the model  Erd\~os--R\'enyi. At the beginning, I used topologies generated by this model for testing.  Finally, I used another open source implementation from a public github repository under MIT license. It is very important to mention and acknowledge in the report any part of code that was not made by me. This was done in the section \ref{chap:5}. This is an example of the importance of open source and shows how people can contribute to the community. 

My contribution to the community is a new simulator of synchronous communication written in Elixir. This simulator is public in github and anyone can contribute or use the simulator to test any synchronous algorithm. I decide to put this implementation under GPLv3 license, to make sure that this code will remain free to anyone. A documentation on how to interact an algorithm with the synchronous simulation is also included in the repository. The main functions of the simulator are also properly documented to make easy understand the code. 

% Plagiarism - correct citation, using code with acknowledgement.